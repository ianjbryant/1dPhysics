<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Test 1</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensures the body takes full viewport height */
            margin: 0;
            background-color: #222222;
        }
        canvas {
            border: 1px solid #d8d8d8; /* Optional: adds a border to the canvas */
            background-color: #222222;
        }
    </style>
</head>
<body>
<canvas id="myCanvas" width="512" height="512"></canvas>
<script>
/*
box:
  vel
  prevmin
  min
  max

collision:
  boxid0
  boxid1
*/
const MAX_BOXES = 32;
const MAX_COLLISIONS = 2*MAX_BOXES;
const BOX_SIZE = 8;
const BOX_ARRAY_SIZE = MAX_BOXES*BOX_SIZE;
var boxes = new Int32Array(BOX_ARRAY_SIZE);
var collisions = new Uint8Array(MAX_COLLISIONS*2);
var bitmap = new Uint8Array(MAX_BOXES);
var group = new Uint8Array(MAX_BOXES);
const TICK_RATE = 20;
const SEC_PER_TICK = 1/TICK_RATE;
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
canvas.addEventListener('contextmenu', (event) => {
  event.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(event.clientX - rect.left);
  const y = canvas.height+1-Math.floor(event.clientY - rect.top);
  const fx = x * 65536;
  const fy = y * 65536;
  for (var i = 0; i < BOX_ARRAY_SIZE; i+=8){
    if(boxes[i+4] != boxes[i+6]) continue;
    boxes[i] = 0;
    boxes[i+1] = 0;
    boxes[i+2] = fx;
    boxes[i+3] = fy;
    boxes[i+4] = fx;
    boxes[i+5] = fy;
    boxes[i+6] = fx + 16*2*65536;
    boxes[i+7] = fy + 32*2*65536;
    break;
  }
});
ctx.translate(0, canvas.height);
ctx.scale(1, -1);
ctx.translate(-0.5, -0.5);
var prevTime = 0;
var accumTime = 0;
function tick(){
  var collisionPtr = 0;
  var t = 1;
  function push(i, j, pt){
    if (pt < 0 || pt > t) return;
    if (collisionPtr > 0 && pt < t) collisionPtr = 0;
    collisions[collisionPtr] = i;
    collisions[collisionPtr+1] = j;
    collisionPtr+=2;
  }
  do {
    collisionPtr = 0;
    for (var i = 0; i < MAX_BOXES; i++){
      const bi = i*8;
      if (boxes[bi+4] == boxes[bi+6]) continue;
      boxes[bi+2] = boxes[bi+4];
      boxes[bi+3] = boxes[bi+5];
      boxes[bi+1] -= 512;
      if (boxes[bi+1] < 0 && boxes[bi+5] <= -boxes[bi+1]){
        push(i, i, boxes[bi+5] / -boxes[bi+1]);
      } else if (boxes[bi+1] > 0){

      }
    }
    for (var i = 0; i < MAX_BOXES-1; i++){
      const bi = i*8;
      if (boxes[bi+4] == boxes[bi+6]) continue;
      for (var j = i+1; j < MAX_BOXES; j++){
        const bj = j*8;
        if (boxes[bj+4] == boxes[bj+6] ||
            boxes[bi+4] >= boxes[bj+6] ||
            boxes[bj+4] >= boxes[bi+6] ||
            boxes[bi+1] == boxes[bj+1]
        ) continue;
        var pt = boxes[bi+7] <= boxes[bj+5] ?
          (boxes[bj+5] - boxes[bi+7]) / (boxes[bi+1] - boxes[bj+1]) :
          (boxes[bi+5] - boxes[bj+7]) / (boxes[bj+1] - boxes[bi+1]);
        push(i, j, pt);
      }
    }
    var next = 0;
    while (next < collisionPtr){
        bitmap.fill(0);
        const na = collisions[next];
        const nb = collisions[next+1];
        bitmap[na] = 1;
        bitmap[nb] = 1;
        var vsum = na == nb ? Infinity : 0;
        var vcount = 0;
        var newnext = 0;
        for (var i = next; i < collisionPtr; i+=3){
            const a = collisions[i];
            const b = collisions[i+1];
            const ba = a*8;
            const bb = b*8;
            if (a == b){
                vsum = Infinity;
                boxes[ba+5] += boxes[ba+1] * ct;
                boxes[ba+1] = 0;
            } else if (bitmap[a] || bitmap[b]){
                bitmap[a] = 1;
                bitmap[b] = 1;
                boxes[ba+5] += boxes[ba+1] * ct;
                boxes[bb+5] += boxes[bb+1] * ct;
                if (vsum == Infinity){
                  boxes[ba+1] = 0;
                  boxes[bb+1] = 0;
                } else {
                  vsum += boxes[ba+1] + boxes[bb+1];
                  group[vcount] = i;
                  vcount++;
                }
            } else if (!newnext){
                newnext = i;
            }
        }
        if (vsum != Infinity){
          var vavg = vsum / vcount;
          for (var i = 0; i < vcount; i++){
              const ii = group[i];
              const ba = 8*collisions[ii];
              const bb = 8*collisions[ii+1];
              boxes[ba+1] = vavg;
              boxes[bb+1] = vavg;
          }
        }
        t -= collisions[2];
        if (!newnext){
            break;
        }
        next = newnext;
    }
  } while (collisionPtr > 0);
  if (t > 0){
    for (var i = 0; i < BOX_ARRAY_SIZE; i+=8){
      if (boxes[i+4] == boxes[i+6]) continue;
      var x = boxes[i] * t;
      var y = boxes[i+1] * t;
      boxes[i+4] += x;
      boxes[i+5] += y;
      boxes[i+6] += x;
      boxes[i+7] += y;
    }
  }
}
function frame(time){
  time /= 1000;
  var dt = 0;
  if (prevTime){
    dt = time - prevTime;
  }
  prevTime = time;
  accumTime += dt;
  while (accumTime > SEC_PER_TICK){
    tick();
    accumTime -= SEC_PER_TICK;
  }
  var remainingTick = accumTime / SEC_PER_TICK;
  ctx.clearRect(0, 0, canvas.width+1, canvas.height+1);
  ctx.strokeStyle = "#d8d800";
  for (var i = 0; i < BOX_ARRAY_SIZE; i+=8){
    if (boxes[i+4] == boxes[i+6]) continue;
    var prevminx = boxes[i+2] / 65536;
    var prevminy = boxes[i+3] / 65536;
    var minx = boxes[i+4] / 65536;
    var miny = boxes[i+5] / 65536;
    var maxx = boxes[i+6] / 65536;
    var maxy = boxes[i+7] / 65536;
    var lerpminx = remainingTick * (minx - prevminx) + prevminx;
    var lerpminy = remainingTick * (miny - prevminy) + prevminy;
    var width = maxx - minx;
    var height = maxy - miny;
    ctx.strokeRect(minx, miny, width, height);
  }
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>